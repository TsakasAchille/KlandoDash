@startuml Support Tickets Flow (Simplified Pagination)
actor User
boundary UI
participant "PendingPagination" as PP
participant "ClosedPagination" as CP
participant "update_pending_tickets_data" as UPTD
participant "update_closed_tickets_data" as UCTD
participant "load_tickets_by_page" as LTBP
participant "SupportTicketRepository" as Repo
database Database
participant "process_ticket_status_update" as PTSU
participant "update_ticket_stores" as UTS
participant "update_ticket_status" as UTSt
participant "update_pending_tickets_list" as UPTL
participant "update_closed_tickets_list" as UCTL
entity "support-tickets-cache" as STC
entity "support-tickets-store" as STS
entity "closed-tickets-cache" as CTC
entity "closed-tickets-store" as CTS
entity "ticket-update-signal" as TUS
boundary DOM

note over User, DOM: Flux des tickets ouverts (PENDING)

User -> PP: Change de page
PP -> UPTD: Input trigger (page)
activate UPTD
UPTD -> LTBP: load_tickets_by_page(page, status="PENDING")
activate LTBP
LTBP -> Repo: get_tickets_by_page(page, page_size=10, status="PENDING")
activate Repo

note right of Repo
  1. Calcul du décalage: skip = (page - 1) * 10
  2. Construction de la requête de base avec session.query(SupportTicket)
  3. Application du filtre via query.filter(SupportTicket.status == status)
  4. Comptage total avec query.count()
end note

Repo -> Database: query.count()
Database --> Repo: total_count

Repo -> Database: query.order_by(SupportTicket.created_at.desc()).offset(skip).limit(page_size).all()
Database --> Repo: Liste d'objets SupportTicket

note right of Repo
  1. Conversion des tickets en schémas via convert_ticket_to_schema
  2. Calcul du nombre total de pages: (total_count + page_size - 1) // page_size
  3. Construction du dictionnaire de retour avec tickets et pagination
end note

Repo --> LTBP: Dict avec tickets et pagination
deactivate Repo

LTBP --> UPTD: Données + pagination + timestamp
deactivate LTBP

UPTD --> PP: Mise à jour max_value avec total_pages
UPTD --> STC: Stockage données dans le cache
deactivate UPTD

STC -> PTD: Input trigger
activate PTD
PTD -> STS: Transfert données
deactivate PTD

STS -> UPTL: Input trigger
activate UPTL
UPTL -> UPTL: render_tickets_list
UPTL --> DOM: Affichage tickets ouverts
deactivate UPTL

note over User, DOM: Flux des tickets fermés (CLOSED)

User -> CP: Change de page
CP -> UCTD: Input trigger (page)
activate UCTD
UCTD -> LTBP: load_tickets_by_page(page, status="CLOSED")
activate LTBP
LTBP -> Repo: get_tickets_by_page(page, page_size=10, status="CLOSED")
activate Repo

note right of Repo
  1. Calcul du décalage: skip = (page - 1) * 10
  2. Construction de la requête de base avec session.query(SupportTicket)
  3. Application du filtre via query.filter(SupportTicket.status == status)
  4. Comptage total avec query.count()
end note

Repo -> Database: query.count()
Database --> Repo: total_count

Repo -> Database: query.order_by(SupportTicket.created_at.desc()).offset(skip).limit(page_size).all()
Database --> Repo: Liste d'objets SupportTicket

note right of Repo
  1. Conversion des tickets en schémas via convert_ticket_to_schema
  2. Calcul du nombre total de pages: (total_count + page_size - 1) // page_size
  3. Construction du dictionnaire de retour avec tickets et pagination
end note

Repo --> LTBP: Dict avec tickets et pagination
deactivate Repo

LTBP --> UCTD: Données + pagination + timestamp
deactivate LTBP

UCTD --> CP: Mise à jour max_value avec total_pages
UCTD --> CTC: Stockage données dans le cache
deactivate UCTD

CTC -> PTD: Input trigger
activate PTD
PTD -> CTS: Transfert données
deactivate PTD

CTS -> UCTL: Input trigger
activate UCTL
UCTL -> UCTL: render_tickets_list
UCTL --> DOM: Affichage tickets fermés
deactivate UCTL

note over User, DOM: Flux de mise à jour du statut d'un ticket (Architecture améliorée)

User -> UI: Clic sur "Mettre à jour"
UI -> PTSU: Déclenche process_ticket_status_update
activate PTSU

PTSU -> UTSt: update_ticket_status(ticket_id, new_status)
activate UTSt
UTSt -> Database: session.query et modification
Database --> UTSt: Commit réussi
UTSt --> PTSU: Retourne (old_status, new_status)
deactivate UTSt

note right of PTSU
  1. Réception de l'ancien et du nouveau statut
  2. Création d'un signal de mise à jour avec:
     - count: incrémenté à chaque mise à jour
     - updated_id: identifiant du ticket
     - old_status: ancien statut
     - new_status: nouveau statut
     - timestamp: horodatage
  3. Émission du signal via le store ticket-update-signal
end note

PTSU --> TUS: Émet signal de mise à jour
deactivate PTSU

TUS -> UTS: Déclenche update_ticket_stores
activate UTS

note right of UTS
  1. Détection du signal de mise à jour 
  2. Récupération des données des tickets actuelles
  3. Suppression immédiate du ticket de la liste source
     - Si ticket fermé: retiré de pending_data["tickets"]
     - Si ticket réouvert: retiré de closed_data["tickets"]
  4. Mise à jour des compteurs de pagination
end note

UTS --> STS: Mise à jour immédiate des tickets en attente
UTS --> CTS: Mise à jour immédiate des tickets fermés
deactivate UTS

TUS -> UPTD: Déclenche le callback si ticket réouvert
TUS -> UCTD: Déclenche le callback si ticket fermé

note right of UPTD
  Vérifie si un ticket a été réouvert
  et rafraîchit la liste complète au besoin
end note

note right of UCTD
  Vérifie si un ticket a été fermé
  et rafraîchit la liste complète au besoin
end note

UPTD --> PP: Met à jour la pagination
UCTD --> CP: Met à jour la pagination

@enduml
