@startuml Support Tickets Flow (Simplified Pagination)
actor User
boundary UI
participant "PendingPagination" as PP
participant "ClosedPagination" as CP
participant "update_pending_tickets_data" as UPTD
participant "update_closed_tickets_data" as UCTD
participant "load_tickets_by_page" as LTBP
participant "SupportTicketRepository" as Repo
database Database
participant "process_tickets_data" as PTD
participant "update_ticket_status" as UTS
participant "update_pending_tickets_list" as UPTL
participant "update_closed_tickets_list" as UCTL
entity "support-tickets-cache" as STC
entity "support-tickets-store" as STS
entity "closed-tickets-cache" as CTC
entity "closed-tickets-store" as CTS
boundary DOM

note over User, DOM: Flux des tickets ouverts (PENDING)

User -> PP: Change de page
PP -> UPTD: Input trigger (page)
activate UPTD
UPTD -> LTBP: load_tickets_by_page(page, status="PENDING")
activate LTBP
LTBP -> Repo: get_tickets_by_page(page, page_size=10, status="PENDING")
activate Repo

note right of Repo
  1. Calcul du décalage: skip = (page - 1) * 10
  2. Construction de la requête de base avec session.query(SupportTicket)
  3. Application du filtre via query.filter(SupportTicket.status == status)
  4. Comptage total avec query.count()
end note

Repo -> Database: query.count()
Database --> Repo: total_count

Repo -> Database: query.order_by(SupportTicket.created_at.desc()).offset(skip).limit(page_size).all()
Database --> Repo: Liste d'objets SupportTicket

note right of Repo
  1. Conversion des tickets en schémas via convert_ticket_to_schema
  2. Calcul du nombre total de pages: (total_count + page_size - 1) // page_size
  3. Construction du dictionnaire de retour avec tickets et pagination
end note

Repo --> LTBP: Dict avec tickets et pagination
deactivate Repo

LTBP --> UPTD: Données + pagination + timestamp
deactivate LTBP

UPTD --> PP: Mise à jour max_value avec total_pages
UPTD --> STC: Stockage données dans le cache
deactivate UPTD

STC -> PTD: Input trigger
activate PTD
PTD -> STS: Transfert données
deactivate PTD

STS -> UPTL: Input trigger
activate UPTL
UPTL -> UPTL: render_tickets_list
UPTL --> DOM: Affichage tickets ouverts
deactivate UPTL

note over User, DOM: Flux des tickets fermés (CLOSED)

User -> CP: Change de page
CP -> UCTD: Input trigger (page)
activate UCTD
UCTD -> LTBP: load_tickets_by_page(page, status="CLOSED")
activate LTBP
LTBP -> Repo: get_tickets_by_page(page, page_size=10, status="CLOSED")
activate Repo

note right of Repo
  1. Calcul du décalage: skip = (page - 1) * 10
  2. Construction de la requête de base avec session.query(SupportTicket)
  3. Application du filtre via query.filter(SupportTicket.status == status)
  4. Comptage total avec query.count()
end note

Repo -> Database: query.count()
Database --> Repo: total_count

Repo -> Database: query.order_by(SupportTicket.created_at.desc()).offset(skip).limit(page_size).all()
Database --> Repo: Liste d'objets SupportTicket

note right of Repo
  1. Conversion des tickets en schémas via convert_ticket_to_schema
  2. Calcul du nombre total de pages: (total_count + page_size - 1) // page_size
  3. Construction du dictionnaire de retour avec tickets et pagination
end note

Repo --> LTBP: Dict avec tickets et pagination
deactivate Repo

LTBP --> UCTD: Données + pagination + timestamp
deactivate LTBP

UCTD --> CP: Mise à jour max_value avec total_pages
UCTD --> CTC: Stockage données dans le cache
deactivate UCTD

CTC -> PTD: Input trigger
activate PTD
PTD -> CTS: Transfert données
deactivate PTD

CTS -> UCTL: Input trigger
activate UCTL
UCTL -> UCTL: render_tickets_list
UCTL --> DOM: Affichage tickets fermés
deactivate UCTL

note over User, DOM: Flux de mise à jour du statut d'un ticket

User -> UI: Clic sur "Mettre à jour"
UI -> PTD: Déclenche process_tickets_data
activate PTD

PTD -> UTS: update_ticket_status(ticket_id, new_status)
activate UTS
UTS -> Database: session.query et modification
Database --> UTS: Commit réussi
UTS --> PTD: Retourne (old_status, new_status)
deactivate UTS

note right of PTD
  1. Réception de l'ancien et du nouveau statut
  2. Mise à jour des deux caches (pending et closed)
  3. Suppression immédiate du ticket de la liste source
     - Si ticket fermé: retiré de pending_data["tickets"]
     - Si ticket réouvert: retiré de closed_data["tickets"]
  4. Mise à jour des compteurs de pagination
  5. Déclenchement d'un rafraîchissement complet
end note

PTD --> STS: Mise à jour immédiate des tickets en attente
PTD --> CTS: Mise à jour immédiate des tickets fermés
PTD -> UI: Déclenche rafraîchissement (refresh_clicks + 1)
deactivate PTD

note over UI, UCTD: Rafraîchissement automatique
UI -> UPTD: Déclenche le callback (refresh_clicks + 1)
UI -> UCTD: Déclenche le callback (refresh_clicks + 1)
UPTD --> PP: Met à jour la pagination
UCTD --> CP: Met à jour la pagination

@enduml
